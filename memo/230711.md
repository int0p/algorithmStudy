## 1000,1001,1008

1008(나눗셈)에서 숫자들 타입 주의. 

참고 코드: [백준 1000번 A+B (Rust) (tistory.com)](https://mesajang.tistory.com/54)

```rust
use std::io;

fn main(){
    //입력 문자열 받아옴
    let mut numbersString = String::new();
    io::stdin().read_line(&mut numbersString).unwrap(); 
    
    //입력 벡터화.
    let numbers: Vec<&str> = numbersString.split_whitespace().collect();
    
    //입력 숫자화.
    let num1 = numbers[0].parse::<f64>().unwrap();
    let num2 = numbers[1].parse::<f64>().unwrap();
    
    println!("{}",num1 / num2);
    
}
```

> 왜 numbersString가 mut여야해?
> 
> - rust에서 mut은 mutable, 변수의 값을 변경할 수 있음을 뜻한다.
> - **`io::stdin().read_line(&mut numbersString).unwrap();`** 코드에서 **`read_line`** 메소드는 사용자로부터 입력을 읽어서 인자로 받은 변수에 저장합니다. 이렇게 하려면 해당 변수는 뮤터블이어야 합니다. 그렇지 않으면 컴파일러는 값을 변경할 수 없는 변수에 대해 값을 변경하려 한다며 컴파일 에러를 발생시킵니다.
> - 즉, 사용자의 입력값을 저장하려면, 변수의 값을 변경할 수 있어야하므로 mut이어야한다.

> 왜 numbersString의 타입이 String이어야해?
> 
> - **`std::io::stdin().read_line()`** 함수는 사용자의 입력을 읽어 문자열 형태로 반환하는 기능을 합니다.
> - `read_line()` 은 string을 입력으로 받으므로, numbersString은 string type이어야한다.
> 
> ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/798f48d2-ec58-482e-a0b7-71a766052973/Untitled.png)
> 

> 왜 입력을 받을 때 `&mut` 을 붙이는거야?
> 
> - 러스트에서의 소유권 개념
>     1. 러스트는 각각의 값은 해당값의 오너라고 불리우는 변수를 가지고 있다.
>     2. 한번에 딱 하나의 오너만 존재할 수 있다.
>         1. 어떤 값을 다른 변수에 대입하면 값이 이동된다. 
>     3. 오너가 스코프 값을 벗어날 때 값은 버려진다.
> - ex. [Rust-Lang의 소유권 이해하기 — baealex (blex.me)](https://blex.me/@baealex/rust-lang%EC%9D%98-%EC%86%8C%EC%9C%A0%EA%B6%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)
>     
>     ```rust
>     fn main() {
>         let my_name = String::from("Jino Bae"); // 1. my_name 생성됨
>         show_my_name(my_name); // 2. show_my_name으로 my_name이 이동함
>         println!("{}", my_name); // 5. my_name이 존재하지 않음
>     }
>     
>     fn show_my_name(name: String) { // 3. my_name이 이동되었음
>         println!("{}", name);
>     } // 4. my_name이 스코프를 벗어나 drop에 의해 삭제됨
>     ```
>     
>     ⇒ 실행결과, name이 한번만 출력됨. 
>     
>     - 변수 my_name의 값을 유지하는 방법
>         1. 함수 show_my_name()에서 name값을 리턴하여 다시 소유권을 이동시킴
>         2. 참조자.
>             1. [빌림] 참조자를 사용하면 변수의 소유권이 넘어가지 않으며, 스코프를 벗어나도 참조자가 가리키는 값은 사라지지 않는다. 
>             2. [ `&mut` 키워드] 빌려온 값(my_name)엔 아무런 변화를 줄 수 없다. 만일, 함수 show_my_name()내에서 name값을 변경하고싶다면, `&mut` 키워드를 사용하면된다. 
> - 결론: **`read_line`** 메소드가 문자열의 값을 변경하기위함.

> .unwrap()가 어떤 의미야?
> 
> - **`.unwrap()`**: 이 메소드는 **`Result`** 객체를 반환하는 함수에 적용됩니다. **`parse`** 메소드는 문자열을 정수로 변환하는 과정에서 문제가 발생할 수 있으므로, **`Result`** 타입의 객체를 반환합니다. 만약 변환 작업이 성공했다면 (즉, **`Ok`** 상태라면) **`unwrap()`**은 **`Ok`**에 저장된 값을 반환하고, 실패했다면 (즉, **`Err`** 상태라면) 프로그램은 패닉 상태가 되고 중단됩니다.

> rust에서 벡터와 배열은 어떻게 달라?
> 
> - 공통점
>     - 동일한 타입의 데이터 저장
>     - 순차적인 메모리 저장 - 메모리 상에서 연속적인 공간에 요소들을 저장한다.
>     - 인덱스 기반 접근
>     - 슬라이싱을 통해 부분적으로 접근 가능
> - 차이점
>     1. 크기의 유연성: 배열의 크기는 고정되어 있고 컴파일 타임에 결정되어야 합니다. 한번 생성된 배열의 크기를 동적으로 변경할 수 없습니다. 반면에 벡터는 크기가 동적으로 변경될 수 있는 데이터 구조입니다. 즉, 실행 시간 동안 요소를 추가하거나 제거할 수 있습니다.
>     2. 메모리 할당: 배열은 스택 메모리에 할당되며, 그 크기와 생명주기는 컴파일 타임에 결정됩니다. 벡터는 힙 메모리에 저장되며, 실행 시간에 크기를 변경할 수 있습니다.
>     3. API: 벡터는 배열보다 더 많은 메소드와 기능을 제공합니다. 예를 들어, **`push`**와 **`pop`** 메소드를 사용하여 요소를 추가하거나 제거할 수 있습니다. 반면에 배열은 이러한 기능을 제공하지 않습니다.
>     
>     요약하면, 배열은 고정된 크기의 동일한 타입의 데이터를 저장하는 데 사용되며, 벡터는 동적인 크기의 동일한 타입의 데이터를 저장하는 데 사용됩니다. 데이터의 양이 미리 알려져 있고 변경되지 않을 때는 배열을 사용하고, 데이터의 양이 런타임에 변경될 수 있을 때는 벡터를 사용하는 것이 일반적입니다.
>     

> .collect()가 어떤 의미야?
> 
> - **`.collect()`**: 이 메소드는 이터레이터를 가져와서 다른 형태의 컬렉션으로 변환합니다. 여기서는 이터레이터의 요소들을 벡터에 모으는 작업을 수행합니다.

> `io::stdin()`  `parse::<f64>()` 에서 `::`이 뭐야?
> 
> - rust에서 `::` 은 주로 구조체, 열거형 또는 모듈의 관련 항목(함수, 메서드, 상수, 데이터)에 접근할 때 사용된다.
>     - `.` 접근방식과의 차이점
>         - **`.`** 연산자는 객체의 메소드를 호출하거나 필드에 접근할 때 사용됩니다. 예를 들어, **`String`** 객체의 **`len`** 메소드를 호출하기 위해 **`my_string.len()`**과 같이 사용할 수 있습니다.
>     - `::`  타입 또는 모듈 자체에 접근할 때 ***vs*** `.`  특정 인스턴스의 메소드나 필드에 접근할 때
> - **`parse::<i32>()`**에서의 **`::`** 기호는 "turbofish"라고도 불리며, 이를 통해 제네릭 함수의 타입을 명시적으로 지정할 수 있습니다. **`parse`** 함수는 문자열을 해당 타입으로 파싱하려고 시도하는 제네릭 함수입니다. 즉, 이 함수는 여러 타입에 대해 작동할 수 있습니다.
>     
>     **`.parse::<i32>()`**을 사용하면 컴파일러에게 이 함수가 **`i32`** 타입으로 파싱하려고 한다는 것을 명확히 알려줍니다. 이렇게 함으로써 타입 추론에 의존하지 않고 명확히 원하는 타입으로 파싱할 수 있습니다.
>     
> - **`io::stdin()`**에서 **`::`**은 **`io`** 모듈 안에 있는 **`stdin`** 함수에 접근하려는 것을 나타냅니다. **`io`**는 Rust의 표준 라이브러리에 있는 모듈로, 여러 가지 I/O 관련 함수와 구조체를 포함하고 있습니다.
>     
>     따라서 **`io::stdin()`**은 **`io`** 모듈 내부의 **`stdin`** 함수를 호출하는 것을 의미합니다.
>